package com.chamelaeon.numberstation;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.io.SequenceInputStream;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;

import javax.sound.sampled.AudioFileFormat;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.SourceDataLine;
import javax.sound.sampled.UnsupportedAudioFileException;

import com.xuggle.xuggler.IAudioResampler;
import com.xuggle.xuggler.IAudioSamples;
import com.xuggle.xuggler.IContainer;
import com.xuggle.xuggler.IPacket;
import com.xuggle.xuggler.IStream;
import com.xuggle.xuggler.IStreamCoder;

/**
 * Generates a broadcast ready to be played on the Numbers Station.
 * 
 * @author Chamelaeon
 */
public class BroadcastGenerator {
	
	/** The encrypter to use. */
	private final Encrypter encrypter;
	/** The converter to use. */
	private final SpeakableTextConverter converter;
	/** The synthesizer to use. */
	private final Synthesizer synthesizer;
	/** The intro to use. */
	private final Intro intro;
	
	/**
	 * Constructor.
	 * @param encrypter The encrypter to use. Must not be null.
	 * @param language The language to use. Must not be null.
	 * @param synthesizer The synthesizer to use. Must not be null.
	 * @param intro The intro to use. Must not be null.
	 */
	public BroadcastGenerator(Encrypter encrypter, Language language, Synthesizer synthesizer, Intro intro) {
		if (null == encrypter) {
			throw new IllegalArgumentException("Encrypter cannot be null!");
		} else if (null == language) {
			throw new IllegalArgumentException("Language cannot be null!");
		} else if (null == synthesizer) {
			throw new IllegalArgumentException("Synthesizer cannot be null!");
		} else if (null == intro) {
			throw new IllegalArgumentException("Intro cannot be null!");
		}
		
		this.encrypter = encrypter;
		this.synthesizer = synthesizer;
		this.converter = language.createConverter();
		this.intro = intro;
		
		this.synthesizer.start();
	}
		
	public void generateBroadcast(String input) { 
		byte[] bytes = encrypter.encrypt(input);
    	List<String> converted = converter.byteToText(bytes);
    	
    	try {
			final File introFile = intro.getIntroFile(synthesizer);

			int repeatCount = intro.getRepeatCount();
			byte[] contentBytes = reencodeContentBytes(synthesizer.synthesize(converted));
			AudioInputStream content = new AudioInputStream(new ByteArrayInputStream(contentBytes), 
					new AudioFormat(44100, 16, 1, true, false), contentBytes.length);
			AudioInputStream sequence = null;
			try {
				sequence = new AudioInputStream(new SequenceInputStream(
						createEnum(introFile, repeatCount, content)),
						AudioSystem.getAudioInputStream(introFile).getFormat(),
						getSizeOfIntros(introFile, repeatCount)
								+ content.getFrameLength());

				File outFile = new File("station.wav");
				AudioSystem.write(sequence, AudioFileFormat.Type.WAVE, outFile);
			} finally {
				try { sequence.close(); } catch (NullPointerException npe) { /* Ignore. */ }
				try { content.close(); } catch (Exception npe) { /* Ignore. */ }
			}
		} catch (IOException ioe) {
			throw new RuntimeException(ioe);
    	} catch (UnsupportedAudioFileException uafe) {
    		throw new RuntimeException(uafe);
		}
	}
	
	public void stop() throws InterruptedException {
		synthesizer.stop();
	}
	
	/**
	 * The available languages for broadcast.
	 * @author Chamelaeon
	 */
	public static enum Language {
		ENGLISH {
			/** {@inheritDoc} */
			@Override
			public SpeakableTextConverter createConverter() {
				return new EnglishSpeakableTextConverter();
			}
		};
		
		public abstract SpeakableTextConverter createConverter();
	}
	
	/**
	 * Describes an intro bump to the numbers station.
	 * @author Chamelaeon
	 */
	public interface Intro {
		
		/**
		 * The number of times to repeat this intro.
		 * @return 
		 */
		public int getRepeatCount();
		
		/**
		 * Returns a file to the intro's content, whether it's
		 * generated by a synthesizer or is just a .wav.
		 * @param synthesizer The synthesizer to use if necessary.
		 * @return the stream to the content.
		 * @throws IOException if there is a problem getting the stream.
		 */
		public File getIntroFile(Synthesizer synthesizer) throws IOException;
	}
	
	/**
	 * An intro that consists of a wav file.
	 * @author Chamelaeon
	 */
	public static class WaveIntro implements Intro {
		/** The number of times to repeat the intro. */
		private final int count;
		
		/** The filename of the intro. */
		private final String filename;
		
		/**
		 * Constructor.
		 * @param repeatCount The number of times to repeat the intro. Must be > 0.
		 * @param filename The filename of the intro. Must not be null or empty.
		 */
		public WaveIntro(int repeatCount, String filename) {
			if (repeatCount < 1) {
				throw new IllegalArgumentException("Repeat count must be greater than 0!");
			} else if (null == filename || filename.trim().equals("")) {
				throw new IllegalArgumentException("Filename must not be null or empty!");
			}
			
			this.count = repeatCount;
			this.filename = filename;
		}
		
		/** {@inheritDoc} */
		@Override
		public File getIntroFile(Synthesizer synthesizer) throws IOException {
			return new File(filename);
		}

		/** {@inheritDoc} */
		@Override
		public int getRepeatCount() {
			return count;
		}
	}
	
	private void playIntroFile(File file, int repeatCount) {
		SourceDataLine auline = null;
        try {
        	AudioInputStream input = AudioSystem.getAudioInputStream(file);
            AudioFormat format = input.getFormat();
            DataLine.Info info = new DataLine.Info(SourceDataLine.class, format);
            auline = (SourceDataLine) AudioSystem.getLine(info);
            auline.open(format);
            auline.start();
            input.close();
            
            for (int i = 0; i < repeatCount; i++) {
            	try {
            		input = AudioSystem.getAudioInputStream(file);
	            	byte[] buffer = new byte[1024]; 
					while (input.available() > 0) {
						input.read(buffer);
						auline.write(buffer, 0, 1024);
					}
            	} finally {
            		input.close();
            	}
			}
        } catch (UnsupportedAudioFileException uafe) {
            throw new RuntimeException(uafe);
        } catch (IOException ioe) {
        	throw new RuntimeException(ioe);
        } catch (LineUnavailableException lue) {
        	throw new RuntimeException(lue);
		} finally {
			auline.close();
		}
	}
	
	private Enumeration<AudioInputStream> createEnum(final File introFile, final int repeatCount, final AudioInputStream content) {
		return new Enumeration<AudioInputStream>() {
			/** Count for the number of streams we have. */
			private int count = 0;
			
			/** {@inheritDoc} */
			@Override
			public boolean hasMoreElements() {
				return count < repeatCount + 1;
			}

			/** {@inheritDoc} */
			@Override
			public AudioInputStream nextElement() {
				try {
					if (count < repeatCount) {
						count++;
						return AudioSystem.getAudioInputStream(introFile);
					} else if (count == repeatCount) {
						count++;
						return content;
					} else {
						throw new IndexOutOfBoundsException("There are not " + count + " streams in the enumeration!");
					}
				} catch (IOException ioe) {
					throw new RuntimeException(ioe);
				} catch (UnsupportedAudioFileException uafe) {
					throw new RuntimeException(uafe);
				}
			}
			
		};
	}
	
	private long getSizeOfIntros(File introFile, int repeatCount) throws IOException, UnsupportedAudioFileException {
		AudioInputStream stream = null;
		try {
			stream = AudioSystem.getAudioInputStream(introFile);
			return stream.getFrameLength() * repeatCount;
		} finally {
			try { stream.close(); } catch (Exception npe) { /* Ignore. */ }
		}
	}
	
	private byte[] reencodeContentBytes(byte[] content) {
		List<byte[]> bytes = new ArrayList<byte[]>();
		IContainer container = IContainer.make();
		// Guess the format
		if (container.open(new ByteArrayInputStream(content), null) < 0) {
			throw new RuntimeException("Xuggler can't open the stream.");
		}
		
		IStream stream = container.getStream(0);
		IStreamCoder coder = stream.getStreamCoder();
		
		if (coder.open() < 0) {
			throw new RuntimeException("Can't open the stream coder.");
		}
		coder.setFlag(IStreamCoder.Flags.FLAG_QSCALE, false);
		IPacket packet = IPacket.make();
		while (container.readNextPacket(packet) >= 0) {
			IAudioSamples inSamples = IAudioSamples.make(1, coder.getChannels());
			IAudioSamples outSamples = IAudioSamples.make(1, coder.getChannels());
			int offset = 0;
			while (offset < packet.getSize()) {
				int bytesDecoded = coder.decodeAudio(inSamples, packet, offset);
				if (bytesDecoded < 1) {
					throw new RuntimeException("Got an error while reading");
				}
				offset += bytesDecoded;
				
				if (inSamples.isComplete()) {
					IAudioResampler resampler = IAudioResampler.make(1, inSamples.getChannels(), 44100, 16000);
					resampler.resample(outSamples, inSamples, inSamples.getNumSamples());
					bytes.add(outSamples.getData().getByteArray(0, outSamples.getSize()));
				}
			}
		}
		
		byte[] appender = new byte[bytes.get(0).length * bytes.size()];
		int offset = 0;
		for (byte[] bs : bytes) {
			System.arraycopy(bs, 0, appender, offset, bs.length);
			offset += bs.length;
		}
		return appender;
	}
}
